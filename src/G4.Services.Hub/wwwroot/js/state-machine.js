/* global setTimeout */

/**
 * Generates a unique identifier (UID) as a hexadecimal string.
 *
 * @returns {string} A unique identifier generated by combining a random number and converting it to a hexadecimal string.
 */
function uid() {
	return Math.ceil(Math.random() * 10 ** 16).toString(16);
}

/**
 * Determines whether a given value is an object.
 *
 * This function checks if the provided value is an object, which includes
 * objects, arrays, and functions. It explicitly excludes `null` and all
 * primitive types such as boolean, number, string, symbol, bigint, and undefined.
 *
 * @param {*} value - The value to be checked.
 * @returns {boolean} - Returns `true` if the value is an object, `false` if it's a primitive type.
 *
 * @example
 * assertObject({});            // returns true
 * assertObject([1, 2, 3]);     // returns true
 * assertObject(function() {}); // returns true
 * assertObject('Hello');       // returns false
 * assertObject(42);            // returns false
 * assertObject(true);          // returns false
 * assertObject(null);          // returns false
 * assertObject(undefined);     // returns false
 */
function assertObject(value) {
	// Exclude `null` since `typeof null` returns 'object', but it's a primitive.
	if (value === null) {
		return false;
	}

	// Check if the type of the value is 'object' or 'function'.
	// In JavaScript, functions are considered objects.
	return (typeof value === 'object' || typeof value === 'function');
}

/**
 * Converts a given string to camelCase.
 *
 * The function processes the input string by:
 * 1. Removing any non-alphanumeric separators (e.g., spaces, dashes, underscores).
 * 2. Capitalizing the first letter of each word except the first one.
 * 3. Ensuring the first character of the resulting string is in lowercase.
 *
 * @param {string} str - The input string to be converted to camelCase.
 * @returns {string} - The camelCase version of the input string. Returns 'N/A' if the input is falsy.
 *
 * @example
 * convertToCamelCase("Hello World"); // "helloWorld"
 * convertToCamelCase("convert_to_camel_case"); // "convertToCamelCase"
 * convertToCamelCase("Convert-This String"); // "convertThisString"
 * convertToCamelCase("alreadyCamelCase"); // "alreadyCamelCase"
 * convertToCamelCase(""); // "N/A"
 */
function convertToCamelCase(str) {
	// If the input string is falsy (e.g., null, undefined, empty), return 'N/A'.
	if (!str) {
		return 'N/A';
	}

	// Step 1: Replace any non-alphanumeric characters followed by a character with the uppercase of that character.
	// This removes separators and capitalizes the following letter.
	const camelCased = str.replace(/[^a-zA-Z0-9]+(.)/g, (_, chr) => chr.toUpperCase());

	// Step 2: Convert the first character to lowercase to adhere to camelCase conventions.
	return camelCased.charAt(0).toLowerCase() + camelCased.slice(1);
}

/**
 * Converts a PascalCase string to a space-separated string.
 *
 * @param {string} str - The PascalCase string to convert.
 * @returns {string} - The converted space-separated string.
 */
function convertPascalToSpaceCase(str) {
	return str ? str.replace(/([A-Z])/g, ' $1').trim() : 'N/A';
}

/**
 * Converts a camelCase string to PascalCase.
 * 
 * @param {string} str - The camelCase string.
 * @returns {string} The PascalCase version of the string.
 */
function convertToPascalCase(str) {
	return str ? str[0].toUpperCase() + str.slice(1) : "";
}

class StateMachine {
	isInterrupted = false;

	constructor(definition) {
		this.definition = definition;
		this.isRunning = false;
	}

	///**
	// * Invokes a specific rule within a given session using automation rules.
	// *
	// * This asynchronous static method performs the following actions:
	// * 1. Converts the provided `step` object into a rule using the `client.convertToRule` method.
	// * 2. Assigns the generated rule to the first job of the first stage in the `automation` configuration.
	// * 3. Sets the driver parameters based on the provided `session`. If `session` is undefined, existing driver parameters are retained.
	// * 4. Invokes the automation process asynchronously using `client.invokeAutomation` and awaits the result.
	// * 5. Extracts the new session identifier from the automation result for further processing.
	// * 6. Returns an object containing the new session identifier and the full automation result.
	// *
	// * @param {Object}  client             - The client instance with `convertToRule` and `invokeAutomation` methods.
	// * @param {Object}  options            - Configuration options for invoking the rule.
	// * @param {string} [options.session]   - The current session identifier. If undefined, existing driver parameters are retained.
	// * @param {Object}  options.step       - The step object to be invoked, containing necessary details for rule conversion.
	// * @param {Object} [options.rule]      - The rule object to be invoked directly, bypassing the conversion from `step`.
	// * @param {Object}  options.automation - The automation configuration object to be modified and used for invocation.
	// *
	// * @returns {Promise<{ session: string, automationResult: Object }>} 
	// *          A promise that resolves to an object containing the new session identifier and the automation result after successfully invoking the rule.
	// *
	// * @throws {Error} Throws an error if the automation invocation fails or if the expected structure is not present in the result.
	// */
	//static async invokeStep(client, options) {
	//	// Convert the provided step object into a rule using the client's utility method.
	//	const rule = options.rule ? options.rule : client.convertToRule(options.step);

	//	// Exclude certain step types from being directly invoked as rules.
	//	const excludeStepTypes = ['STAGE', 'JOB', 'LOOP', 'IF', 'CONTAINER'];
	//	if (excludeStepTypes.includes(options.step.type?.toUpperCase())) {
	//		return;
	//	}

	//	// Create an array of rules, currently containing only the converted rule.
	//	const rules = [rule];

	//	// Assign the generated rules to the first job of the first stage in the automation configuration.
	//	// Assumes that the automation configuration has at least one stage and one job.
	//	options.automation.stages[0].jobs[0].rules = rules;

	//	// Update the driver parameters based on the provided session.
	//	// If `session` is undefined, retain the existing driver parameters.
	//	// Otherwise, set the driver to reference the new session ID.
	//	options.automation.driverParameters = options.session === undefined
	//		? options.automation.driverParameters
	//		: { driver: `Id(${options.session})` };

	//	try {
	//		// Invoke the automation process asynchronously and wait for the result.
	//		const automationResult = await client.invokeAutomation(options.automation);

	//		// Extract the first key from the automation result object.
	//		// This key typically represents the main response or a specific response type.
	//		const responseKey = Object.keys(automationResult)[0];

	//		// Extract the first session ID from the sessions object within the response.
	//		// This assumes that there is at least one session present in the response.
	//		options.session = Object.keys(automationResult[responseKey].sessions)[0];

	//		// Return an object containing the new session ID and the full automation result.
	//		return {
	//			session: options.session,
	//			automationResult
	//		};
	//	} catch (error) {
	//		// Handle any errors that occur during the automation invocation.
	//		console.error('Automation invocation failed:', error);

	//		// Rethrow the error after logging to allow further handling upstream.
	//		throw error;
	//	}
	//}

	/**
	 * Initiates the automation process.
	 * Sets up the G4 client, creates an automation instance, and iterates
	 * over each step defined in the sequence. Each step is invoked asynchronously
	 * with a configurable delay (speed) before execution.
	 *
	 * @async
	 * @function start
	 * @returns {Promise<void>} Resolves when the entire sequence of steps has finished processing.
	 */
	async start() {
		// Retrieve the automation definition from the current instance
		const definition = this.definition;

		// Create a new G4 client instance
		const client = new G4Client();

		// Instantiate a new automation object from the client
		const automation = client.newAutomation(definition);

        // Start the automation process by invoking the first step
		_connection.invoke("StartAutomation", automation)
	}
}

// eslint-disable-next-line @typescript-eslint/no-unused-vars
class StateMachineSteps {
	/**
	 * Creates a new Stage container for the G4 Automation Sequence.
	 * 
	 * A Stage is a container that holds Jobs, each comprising specific Actions, to structure and manage the sequential automation flow.
	 * Stages organize tasks into logical groups, enabling efficient execution, resource allocation, monitoring, and error handling within the automation sequence.
	 *
	 * @param {string} name       - The name of the Stage container.
	 * @param {Object} properties - The properties defining the Stage container.
	 * @param {Object} parameters - The parameters associated with the Stage.
	 * @param {Array}  steps      - The steps or actions that belong to the Stage.
	 * @returns {Object} A new Stage container object created by the newG4Container function.
	 */
	static newG4Stage(name, properties, parameters, steps) {
		// Description of the Stage container, detailing its purpose and functionalities within the G4 Automation Sequence.
		const stageDescription = `
        A container that holds jobs, each comprising specific actions, to structure and manage the sequential automation flow.
        Stages organize tasks into logical groups, enabling efficient execution, resource allocation, monitoring, and error handling within the automation sequence.`;

		// Initialize the Stage container using the newG4Container function.
		const container = StateMachineSteps.newG4Container(name, 'stage', stageDescription, properties, parameters, steps);
		container["pluginType"] = 'Container'
		container["pluginName"] = 'G4™ Stage'

		// Return the Stage container.
		return container;
	}

	/**
	 * Creates a new Job container within a Stage for the G4 Automation Sequence.
	 *
	 * A Job is a container that holds Actions, organizing and executing them as part of a Job within a Stage.
	 * Job containers manage specific tasks, handle dependencies between actions, coordinate execution,
	 * and ensure efficient resource utilization and error handling within the automation sequence.
	 * By encapsulating related actions, Job containers facilitate modularity, scalability, and maintainability,
	 * allowing complex automation workflows to be broken down into manageable and reusable components.
	 *
	 * @param {string} name       - The name of the Job container.
	 * @param {Object} properties - The properties defining the Job container.
	 * @param {Object} parameters - The parameters associated with the Job.
	 * @param {Array}  steps      - The steps or actions that belong to the Job.
	 * @returns {Object} A new Job container object created by the newG4Container function.
	 */
	static newG4Job(name, properties, parameters, steps) {
		// Description of the Job container, detailing its purpose and functionalities within the G4 Automation Sequence.
		const jobDescription = `
        A container that holds actions, organizing and executing them as part of a job within a stage.
        Job containers manage specific tasks, handle dependencies between actions, coordinate execution,
        and ensure efficient resource utilization and error handling within the automation sequence.
        By encapsulating related actions, job containers facilitate modularity, scalability, and maintainability,
        allowing complex automation workflows to be broken down into manageable and reusable components.`;

		// Initialize the Job container using the newG4Container function.
		let container = StateMachineSteps.newG4Container(name, 'job', jobDescription, properties, parameters, steps);
		container["pluginType"] = 'Container'
		container["pluginName"] = 'G4™ Job'

		// Return the Job container.
		return container;
	}

	/**
	 * Creates a new G4 container object for use in a workflow.
	 *
	 * @param {string} name        - The name of the container.
	 * @param {string} type        - The type of the container (e.g., "stage", "job").
	 * @param {string} description - A brief description of the container.
	 * @param {Object} properties  - An object containing properties for the container.
	 * @param {Object} parameters  - An object containing parameters for the container.
	 * @param {Array}  steps       - An array of steps or sub-containers to include in the container's sequence.
	 * @returns {Object} A new container object with a unique ID and specified properties.
	 */
	static newG4Container(name, type, description, properties, parameters, steps) {
		return {
			description: description || 'Description not provided.',
			id: uid(),                    // Generate a unique identifier for the container.
			componentType: 'container',   // Specify the component type as "container".
			type,                         // The type of the container (e.g., stage, job).
			name,                         // The name of the container.
			parameters: parameters || {}, // Parameters specific to the container.
			properties: properties || {}, // Properties specific to the container.
			sequence: steps || [],        // The sequence of steps or sub-containers; defaults to an empty array.
			context: {}                   // The context object for storing additional information.
		};
	}

	/**
	 * Creates a new G4 step based on the provided manifest.
	 *
	 * @param {Object} manifest - The manifest object containing properties and parameters.
	 * @returns {Object} The newly created G4 step object.
	 */
	static newG4Step(manifest) {
		// Function to convert PascalCase to space-separated words
		const convertPascalToSpaceCase = str => str.replace(/([A-Z])/g, ' $1').trim();

		// Creates a new bridge object from a G4 parameter object.
		const newBridgeObject = (g4ParameterObject) => {
			let bridgeObject = {
				description: g4ParameterObject.description.join('\n'),  // Set summary
				name: convertPascalToSpaceCase(g4ParameterObject.name), // Convert name to space case
				required: g4ParameterObject.mandatory || false,         // Set required flag
				type: g4ParameterObject.type || 'String',               // Set type or default to 'String'
				value: g4ParameterObject.default || '',                 // Set default value or empty string
				optionsList: g4ParameterObject.values || []             // Set options or default to an empty array
			};

			// TODO: Consider to remove this condition
			if (bridgeObject.type.toUpperCase() === 'STRING' || bridgeObject.type.toUpperCase() === 'ANY') {
				bridgeObject.multiLine = false;
			}

			// Return the bridge object
			return bridgeObject;
		}

		// Initialize properties and parameters objects
		const properties = {};
		const parameters = {};

		// Process each property in manifest.properties
		if (manifest.properties) {
			for (const property of manifest.properties) {
				const name = convertToCamelCase(property.name);
				properties[name] = newBridgeObject(property);
			}
		}

		// Process each parameter in manifest.parameters
		if (manifest.parameters) {
			for (const parameter of manifest.parameters) {
				const name = convertToCamelCase(parameter.name);
				parameters[name] = newBridgeObject(parameter);
			}
		}

		// Check if the manifest has categories and determine if it is a condition or loop
		const context = manifest.context?.integration?.sequentialWorkflow || {};
		const componentType = context?.componentType?.toLowerCase() || "taks";
		const iconProvider = context?.iconProvider?.toLowerCase() || "task";
		const label = context?.label || convertPascalToSpaceCase(manifest.key);
		const isSwitch = componentType === "switch";
		const isLoop = componentType === "loop";
		const isContainer = componentType === "container";

		// Initialize the new G4 step object
		let step = {
			componentType: componentType,
			type: iconProvider
		};

		// TODO: Take branches for the manifest or initialize an empty branches collection - will be available on next api release.
		// Check if the manifest is a condition and initialize the branches object
		if (isSwitch) {
			const branches = {};
			const contextBranches = manifest.context?.integration?.sequentialWorkflow?.branches || [];
			for (const branch of contextBranches) {
				branches[branch] = [];
			}
			step.branches = branches;
		}

		// Check if the manifest is a loop or container and initialize the sequence array
		if (isLoop || isContainer) {
			step.sequence = [];
		}

		// Set the remaining properties of the new G4 step object
		step.categories = manifest.categories ? manifest.categories.join("|").toUpperCase() : "";
		step.description = manifest.summary ? manifest.summary.join('\n') : 'Description not provided.';
		step.id = uid();
		step.name = label;
		step.parameters = parameters;
		step.pluginName = manifest.key;
		step.aliases = manifest.aliases || [];
		step.pluginType = manifest.pluginType;
		step.properties = properties;
		step.context = context;

		// Return the new G4 step object
		return step;
	}
}

// Client for sending requests to the G4 API.
class G4Client {
	/**
	 * Creates an instance of G4Client.
	 * @param {string} baseUrl - The base URL for the G4 API.
	 */
	constructor(baseUrl = "http://localhost:9944/api/v4/g4") {
		// The base URL for the API.
		this.baseUrl = baseUrl;

		// The URL endpoint to invoke an automation sequence.
		this.invokeUrl = `${this.baseUrl}/automation/invoke`;

		// The URL endpoint to initialize an automation sequence.
		this.initializeUri = `${this.baseUrl}/automation/init`;

		// The URL endpoint to resolve macros in an automation sequence.
		this.macrosUrl = `${this.baseUrl}/automation/resolve`;

		// The URL endpoint to fetch plugin manifests.
		this.manifestsUrl = `${this.baseUrl}/integration/manifests`;

		// The URL endpoint for the cache (if needed for future use).
		this.cacheUrl = `${this.baseUrl}/integration/cache`;

		// An in-memory cache to store fetched manifests.
		this.manifests = [];
	}

	/**
	 * Asserts that all entities within each extraction of the plugin response have a valid 'Evaluation' status.
	 *
	 * This method checks whether every extraction in the provided `pluginResponse` contains entities
	 * where the 'Evaluation' field is either missing or explicitly set to `true`. If any entity has
	 * an 'Evaluation' field set to `false` or any other falsy value, the assertion fails.
	 *
	 * @param {Object} pluginResponse - The response object from the plugin containing extraction data.
	 * @param {Array}  pluginResponse.extractions                      - An array of extraction objects to be validated.
	 * @param {Array}  pluginResponse.extractions[].entities           - An array of entity objects within each extraction.
	 * @param {Object} pluginResponse.extractions[].entities[].content - The content object of each entity, potentially containing an 'Evaluation' field.
	 *
	 * @returns {boolean} Returns `true` if all entities pass the validation criteria, otherwise `false`.
	 *
	 * @throws {TypeError} Throws an error if `pluginResponse` is not an object or if `extractions` is not an array.
	 *
	 * @example
	 * const pluginResponse = {
	 *     extractions: [
	 *         {
	 *             entities: [
	 *                 { content: { name: 'Entity1', Evaluation: true } },
	 *                 { content: { name: 'Entity2' } } // 'Evaluation' is missing, considered true
	 *             ]
	 *         },
	 *         {
	 *             entities: [
	 *                 { content: { name: 'Entity3', Evaluation: true } },
	 *                 { content: { name: 'Entity4', Evaluation: false } } // Evaluation is false
	 *             ]
	 *         }
	 *     ]
	 * };
	 *
	 * const isValid = assertPlugin(pluginResponse);
	 * console.log(isValid); // Output: false
	 */
	assertPlugin(pluginResponse) {
		// Extract the 'extractions' array from the pluginResponse object
		const extractions = pluginResponse.extractions;

		// Ensure that 'extractions' is an array and perform validation
		if (!extractions || !Array.isArray(extractions) || extractions.length === 0) {
			return false;
		}

		// Ensure that 'extractions' is an array and perform validation
		return extractions.every(extraction =>
			extraction.entities.every(entity => {
				// If the 'Evaluation' field is missing in the entity's content, consider it as false
				if (!('Evaluation' in entity.content)) {
					return false;
				}
				// If the 'Evaluation' field exists, it must be explicitly set to true
				return entity.content["Evaluation"] === true;
			})
		);
	}

	/**
	 * Converts a step configuration object into a rule object.
	 * 
	 * @param {Object} step            - The step object containing all necessary details.
	 * @param {Object} step.context    - An object containing context details, such as $type or model.
	 * @param {string} step.pluginName - The name of the plugin associated with this step.
	 * @param {string} step.id         - A unique identifier for this step.
	 * @param {Object} step.properties - Key-value pairs of property definitions.
	 * @param {Object} step.parameters - Key-value pairs describing parameters and their types.
	 * @param {Array}  step.sequence   - An array of nested steps (if any).
	 * 
	 * @returns {Object} A rule object derived from the given step configuration.
	 */
	convertToRule(step) {
		const convertConditionRuleModel = (step) => {
			const branches = Object.keys(step.branches);
			const ruleBranches = {};

			for (const branch of branches) {
				const branchSteps = step.branches[branch];

				for (const branchStep of branchSteps) {
					const childRule = this.convertToRule(branchStep);
					ruleBranches[branch] = ruleBranches[branch] || [];
					ruleBranches[branch].push(childRule);
				}
			};

			return ruleBranches;
		};

		/**
		 * Converts an array parameter into a formatted string of command-line arguments.
		 *
		 * @param {Object}        parameter         - The parameter object containing the name and value.
		 * @param {string}        parameter.name    - The name of the parameter.
		 * @param {Array<string>} [parameter.value] - An array of values for the parameter.
		 * 
		 * @returns {string} - A string of formatted command-line arguments. Returns an empty string if the value array is empty.
		 */
		const convertFromArray = (parameter) => {
			// If parameter.value is undefined or null, default it to an empty array.
			parameter.value = parameter.value || [];

			// If no values exist, return an empty string.
			if (parameter.value.length === 0) {
				return "";
			}

			// Extract the name from the parameter object.
			const name = parameter.name;

			// Map each value to a "--name:value" format and join them with spaces.
			return parameter.value.map(item => `--${name}:${item}`).join(" ");
		}

		/**
		 * Converts a dictionary parameter into a formatted string of command-line arguments.
		 *
		 * @param {Object} parameter            - The parameter object containing the name and value.
		 * @param {string} parameter.name       - The name of the parameter.
		 * @param {Object} [parameter.value]    - An object representing key-value pairs for the parameter.
		 * 
		 * @returns {string} - A string of formatted command-line arguments. Returns an empty string if the value object is empty.
		 */
		const convertFromDictionary = (parameter) => {
			// If parameter.value is undefined or null, default it to an empty object.
			parameter.value = parameter.value || {};

			// Extract all keys from the dictionary.
			const keys = Object.keys(parameter.value);

			// If no keys exist, return an empty string.
			if (keys.length === 0) {
				return "";
			}

			// Extract the name from the parameter object.
			const name = parameter.name;

			// Map each key-value pair to a "--name:key=value" format and join them with spaces.
			return keys.map(key => `--${name}:${key}=${parameter.value[key]}`).join(" ");
		}

		/**
		 * Processes the parameters from the given step object and returns a single aggregated
		 * string of command-line arguments in the format "{{$ --key:value --key2:value2 ...}}".
		 *
		 * @param {Object} step - The step object containing parameters.
		 * 
		 * @returns {string} A formatted command-line arguments string, or an empty string if no parameters.
		 */
		const formatParameters = (step) => {
			// This will hold all parameter tokens, e.g., ["--key:value", "--key2:value2", ...].
			let parameters = [];

			// We’ll reuse parameterToken for each parameter we process.
			let parameterToken = '';

			// Iterate over each parameter within step.parameters.
			for (const key in step.parameters) {
				// Determine the parameter type and transform to uppercase for consistency.
				const parameterType = step.parameters[key].type.toUpperCase();
				// Retrieve the value.
				const value = step.parameters[key].value;

				// Check for different parameter types.
				const isArray = value && parameterType === 'ARRAY';
				const isDictionary = value && (parameterType === 'DICTIONARY'
					|| parameterType === 'KEY/VALUE'
					|| parameterType === 'OBJECT');
				const isBoolean = parameterType === 'SWITCH';
				const isValue = !isDictionary && !isArray && value && value.length > 0;

				// Construct the parameter token based on its type.
				if (isBoolean && isValue) {
					// Boolean type usually doesn't need a value, just the presence of the flag.
					parameterToken = `--${key}`;
				}
				else if (isValue) {
					// Simple string or numeric value type: "--key:value".
					parameterToken = `--${key}:${value}`;
				}
				else if (isArray) {
					// Array type: convert using convertFromArray().
					parameterToken = convertFromArray(step.parameters[key]);
				}
				else if (isDictionary) {
					// Dictionary type: convert using convertFromDictionary().
					parameterToken = convertFromDictionary(step.parameters[key]);
				}
				else if (!parameterToken || parameterToken === "") {
					// If there's no valid token, skip.
					continue;
				}
				else {
					// Otherwise, skip as well.
					continue;
				}

				// Push the resulting token to the parameters array.
				parameters.push(`${parameterToken}`);
			}

			// Join all parameter tokens with spaces and wrap them with the required format "{{$ ...}}".
			return parameters.length > 0 ? `{{$ ${parameters.join(" ")}}}` : "";
		}

		/**
		 * Determines the rule type based on the step's context object. If the context contains a "$type" key,
		 * or if a 'model' property ending with "RuleModel" is found, it returns the appropriate value. 
		 *
		 * @param {Object} step - The step containing the context.
		 * @returns {string} The resolved rule type.
		 */
		const getRuleType = (step) => {
            // Extract the keys from the step's context object.
			const keys = Object.keys(step.context);

            // Determine the rule type based on the context.
			let type = keys.includes("$type") ? step.context["$type"] : "Action";

			// If step.context.model exists, strip "RuleModel" from the end of the string.
			if (step.context.model) {
				type = step.context.model.replace("RuleModel", "");
			}

            // Return the resolved rule type.
			return type;
		}

		/**
		 * Helper function that converts strings to camelCase format.
		 * 
		 * @param {string} str - The original string.
		 * 
		 * @returns {string} - The camelCase converted string.
		 */
		function convertToCamelCase(str) {
			return str.replace(/[\.\-_](\w|$)/g, (_, x) => x.toUpperCase());
		}

		// Construct the base rule object with type, pluginName, and a reference ID.
		const rule = {
			"$type": getRuleType(step),
			"pluginName": step.pluginName,
			"reference": {
				"id": step.id
			}
		}

		// Iterate over the step's properties to populate the rule object.
		for (const key in step.properties) {
			// Convert the property key to camelCase.
			const propertyKey = convertToCamelCase(key);

			// Assign the property's value to the rule object using the camelCase key.
			rule[propertyKey] = step.properties[key].value;
		}

		// Format all parameters into a single argument string.
		const parameters = formatParameters(step);

		// If parameters exist, set them on the rule's argument property.
		if (parameters && parameters !== "") {
			rule.argument = parameters;
		}

		// If the step context model is a condition rule model, convert the branches.
		const model = step.context.model.toUpperCase();
		if (model === "SWITCHRULEMODEL" || model === "CONDITIONRULEMODEL") {
            // Convert the branches to rules and negativeRules.
			const branches = convertConditionRuleModel(step);

            // Assign the branches to the rule object.
			rule.branches = branches;

            // Return the rule object with the branches.
			return rule;
		}

		// If there's no sequence in the step, we can return the rule here.
		if (!step.sequence || step.sequence.length === 0) {
			return rule;
		}

		// Otherwise, process each step in the sequence recursively (assuming 'this.convert' is defined elsewhere).
		const rules = []
		for (const nestedStep of step.sequence) {
            // Convert the nested step to a rule object.
			const childRule = this.convertToRule(nestedStep);

            // If the child rule is not null, add it to the rules array.
			rules.push(childRule);
		}

		// Assign the array of child rules to our main rule under 'rules'.
		rule.rules = rules;

		// Finally, return the fully-constructed rule object.
		return rule;
	}

	// TODO: refactor to iterate every parameter and property value and replace them in the original step
	syncStep(step, rule) {
		/**
		 * Parses the argument string (e.g. "{{$ --param1:value1 --param2 --param3:subKey=value3}}")
		 * and returns a structured object describing each parameter with its potential type and values.
		 *
		 * @param {string} arg - The argument string from the rule (e.g. "{{$ --param1:value1 --param2}}").
		 * @returns {Object} An object of parameterName → { type, values }, where `values` holds
		 *                   either booleans, arrays, dictionaries, or single values.
		 *
		 * Example return shape:
		 * {
		 *   param1: { type: 'STRING', values: ['value1'] },
		 *   param2: { type: 'SWITCH', values: [true] },
		 *   param3: { type: 'ARRAY', values: ['val1','val2'] },
		 *   config: { type: 'DICTIONARY', values: [{subKey: 'value'}, {anotherKey: 'anotherVal'}] }
		 * }
		 */
		function formatArgumentString(arg = "") {
			// If there's no argument or it doesn't have the "{{$" prefix, return empty.
			if (!arg.includes("{{$")) {
				return {};
			}

			// Extract the content between "{{$ " and "}}" (remove the templating braces).
			// e.g. "{{$ --param1:value1 --param2}}" -> "--param1:value1 --param2"
			const trimmed = arg.replace("{{$", "").replace("}}", "").trim();

			// Split by space to get each token like ["--param1:value1", "--param2", "--param3:subKey=value3", ...].
			const tokens = trimmed.split(/\s+/);

			// Object that will accumulate data in intermediate form:
			// e.g. {
			//   param1: [ { raw: '--param1:value1', key: 'param1', subKeyValue: 'value1' } ],
			//   param2: [ { raw: '--param2', key: 'param2' } ],
			//   param3: [ { raw: '--param3:subKey=value3', key: 'param3', subKey: 'subKey', subValue: 'value3' } ],
			// }
			const paramMap = {};

			for (const token of tokens) {
				if (!token.startsWith("--")) {
					continue; // skip non-parameter tokens (unlikely but safe).
				}

				// Remove the leading "--"
				const withoutDashes = token.slice(2);

				// Patterns to detect:
				// 1) "param" (boolean switch)        => no colons
				// 2) "param:value" (single/array)    => one colon
				// 3) "param:subKey=value" (dict)     => one colon + '='
				//
				// Let's check if there's a colon.
				const colonIndex = withoutDashes.indexOf(":");
				if (colonIndex === -1) {
					// This is a boolean/switch param, e.g. "--param"
					const paramName = withoutDashes;
					paramMap[paramName] = paramMap[paramName] || [];
					paramMap[paramName].push({ raw: token, key: paramName, isSwitch: true });
					continue;
				}

				// If there's a colon, separate the part before the colon from after it.
				const paramName = withoutDashes.slice(0, colonIndex);
				const remainder = withoutDashes.slice(colonIndex + 1);

				// For dictionary-like tokens, we expect "subKey=value"
				// Check if there's an '=' in remainder
				const eqIndex = remainder.indexOf("=");
				if (eqIndex === -1) {
					// No '=', so it's a single or array param, e.g. "--param:value"
					const paramValue = remainder;
					paramMap[paramName] = paramMap[paramName] || [];
					paramMap[paramName].push({
						raw: token,
						key: paramName,
						value: paramValue
					});
				} else {
					// We have a subKey=value scenario, e.g. "--param:subKey=value"
					const subKey = remainder.slice(0, eqIndex);
					const subValue = remainder.slice(eqIndex + 1);
					paramMap[paramName] = paramMap[paramName] || [];
					paramMap[paramName].push({
						raw: token,
						key: paramName,
						subKey,
						subValue
					});
				}
			}

			// Now we convert `paramMap` into a friendlier shape with inferred parameter types.
			const structuredParams = {};

			for (const [paramName, entries] of Object.entries(paramMap)) {
				// If any entry has "isSwitch" = true, we call it a SWITCH param.
				// (Though it’s possible an advanced user might do something crazy mixing forms, we’ll assume consistency.)
				const isSwitchParam = entries.some(e => e.isSwitch);
				if (isSwitchParam) {
					structuredParams[paramName] = {
						type: "SWITCH",
						// We can store "true" or "on" or something. 
						// Original code used isValue to detect if switch is present. So let's store "true".
						value: "true"
					};
					continue;
				}

				// Check for dictionary style: if all have subKey & subValue, it's dictionary
				const isDictionary = entries.every(e => typeof e.subKey !== "undefined");
				if (isDictionary) {
					// e.g. paramName: [ { subKey: 'host', subValue: 'localhost' }, { subKey: 'port', subValue: '8080' } ]
					const dictObj = {};
					for (const dictEntry of entries) {
						dictObj[dictEntry.subKey] = dictEntry.subValue;
					}
					structuredParams[paramName] = {
						// The original function used "DICTIONARY", "KEY/VALUE", or "OBJECT" interchangeably.
						// We'll pick "DICTIONARY" for consistency.
						type: "DICTIONARY",
						value: dictObj
					};
					continue;
				}

				// Otherwise, check for multiple single values → array
				// If there's more than one entry, or the developer specifically repeated them, treat as array.
				if (entries.length > 1) {
					// e.g. paramName: [ { value: 'val1' }, { value: 'val2' } ]
					structuredParams[paramName] = {
						type: "ARRAY",
						value: entries.map(e => e.value)
					};
					continue;
				}

				// If there's exactly one entry with a "value", it's a single-value (string).
				structuredParams[paramName] = {
					type: "STRING",
					value: entries[0].value
				};
			}

			return structuredParams;
		}

		// Convert each key in rule to a property, skipping known fields.
		const includeKeys = ["argument", "locator", "locatorType", "onAttribute", "onElement", "regularExpression"];
		for (const key in rule) {
			if (!includeKeys.includes(key) || !(key in step.properties)) {
				continue;
			}
			// The remaining keys are assumed to be "property keys" in camelCase form.
			step.properties[key]["resolvedValue"] = rule[key];
		}

		// Parse the argument string back into parameters, if present.
		if (rule.argument) {
			const parsedParams = formatArgumentString(rule.argument);
			for (const [paramName, paramInfo] of Object.entries(parsedParams)) {
				step.parameters[paramName]["resolvedValue"] = paramInfo.value;
			}
		}

		// Return the reconstructed step object.
		return step;
	}

	/**
	 * Searches for a plugin within the provided G4 response model that matches the given reference ID.
	 *
	 * This function traverses the nested structure of the G4 response model, iterating through sessions,
	 * response trees, stages, jobs, and plugins to locate a plugin with a matching reference ID.
	 *
	 * @param {string} referenceId     - The reference ID to search for within the plugins.
	 * @param {Object} g4ResponseModel - The G4 response model object containing nested plugin data.
	 *
	 * @returns {Object|null} The plugin object that matches the reference ID, or null if not found.
	 *
	 * @throws {TypeError} Throws an error if `g4ResponseModel` is not a non-null object or if `referenceId` is not a string.
	 *
	 * @example
	 * const referenceId = 'plugin-12345';
	 * const g4ResponseModel = {
	 *     response1: {
	 *         sessions: {
	 *             session1: {
	 *                 responseTree: {
	 *                     stages: [
	 *                         {
	 *                             jobs: [
	 *                                 {
	 *                                     plugins: [
	 *                                         { performancePoint: { reference: { id: 'plugin-12345' } }, name: 'Plugin A' },
	 *                                         { performancePoint: { reference: { id: 'plugin-67890' } }, name: 'Plugin B' }
	 *                                     ]
	 *                                 }
	 *                             ]
	 *                         }
	 *                     ]
	 *                 }
	 *             }
	 *         }
	 *     }
	 * };
	 *
	 * const foundPlugin = findPlugin(referenceId, g4ResponseModel);
	 * console.log(foundPlugin);
	 * // Output: { performancePoint: { reference: { id: 'plugin-12345' } }, name: 'Plugin A' }
	 */
	findPlugin(referenceId, g4ResponseModel) {
		/**
		 * Generator function to traverse all plugins within the G4 response model.
		 *
		 * Iterates through each response, session, response tree, stage, job, and plugin,
		 * yielding each plugin encountered.
		 *
		 * @param {Object} g4ResponseModel - The G4 response model to traverse.
		 * @yields {Object} Each plugin object found within the response model.
		 */
		function* traversePlugins(g4ResponseModel) {
			// Iterate over each response in the G4 response model
			for (const response of Object.values(g4ResponseModel)) {
				// Extract the sessions object from the current response
				const sessions = response.sessions;

				// Continue to the next response if sessions is not an object
				if (!sessions || typeof sessions !== 'object') continue;

				// Iterate over each session within the current response
				for (const session of Object.values(sessions)) {
					// Extract the response tree object from the current session
					const responseTree = session.responseTree;

					// Continue to the next session if responseTree is not an object
					if (!responseTree || typeof responseTree !== 'object') continue;

					const stages = responseTree.stages;
					// Continue to the next session if stages is not an array
					if (!Array.isArray(stages)) continue;

					// Iterate over each stage within the response tree
					for (const stage of stages) {
						// Extract the jobs array from the current stage
						const jobs = stage.jobs;

						// Continue to the next stage if jobs is not an array
						if (!Array.isArray(jobs)) continue;

						// Iterate over each job within the current stage
						for (const job of jobs) {
							// Extract the plugins array from the current job
							const plugins = job.plugins;

							// Continue to the next job if plugins is not an array
							if (!Array.isArray(plugins)) continue;

							// Iterate over each plugin within the current job and yield it
							for (const plugin of plugins) {
								yield plugin;
							}
						}
					}
				}
			}
		}

		// Input validation to ensure `g4ResponseModel` is a non-null object
		if (typeof g4ResponseModel !== 'object' || g4ResponseModel === null) {
			throw new TypeError('g4ResponseModel must be a non-null object');
		}

		// Input validation to ensure `referenceId` is a string
		if (typeof referenceId !== 'string') {
			throw new TypeError('referenceId must be a string');
		}

		// Traverse through all plugins and search for the one with the matching reference ID
		for (const plugin of traversePlugins(g4ResponseModel)) {

			// Check if the plugin's performancePoint.reference.id matches the referenceId
			// Return the matching plugin
			if (plugin.performancePoint?.reference?.id === referenceId) {
				return plugin;
			}
		}

		// Return null if no matching plugin is found
		return null;
	}

	/**
	 * Fetches the G4 cache from the API.
	 *
	 * @async
	 * 
	 * @returns {Promise<Object>} A promise that resolves to the cached data retrieved from the API.
	 * 
	 * @throws {Error} Throws an error if the network request fails or the response is not OK.
	 */
	async getCache() {
		try {
			// Fetch the cache data from the API using the cacheUrl endpoint.
			const response = await fetch(this.cacheUrl);

			// Check if the response status indicates success (HTTP 200-299).
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON data from the response.
			const data = await response.json();

			// Return the parsed cache data.
			return data;
		} catch (error) {
			// Log the error to the console for debugging.
			console.error('Failed to fetch G4 cache:', error);

			// Rethrow the error to ensure the caller is aware of the failure.
			throw new Error(error);
		}
	}

	/**
	 * Retrieves and organizes plugin manifests into groups based on their categories and scopes.
	 *
	 * @async
	 * 
	 * @returns {Promise<Object>} A promise that resolves to an object containing grouped manifests. Each group is keyed by category (and optionally scope) with its corresponding manifests.
	 */
	async getGroups() {
		// Function to convert PascalCase to space-separated words.
		const convertPascalToSpaceCase = (str) => str.replace(/([A-Z])/g, ' $1').trim();

		// Fetch the manifests using the existing method.
		const manifests = await this.getManifests();

		// Initialize an empty object to store the groups.
		const groups = {};

		// Iterate through each manifest in the manifests object.
		for (const manifest of Object.values(manifests)) {
			// Ensure the manifest has a 'scopes' array.
			manifest.scopes = manifest.scopes || [];

			// Determine if the manifest has a scope that includes 'ANY' (case-insensitive).
			const isAnyScope = manifest.scopes.some(scope => scope.toUpperCase() === 'ANY') || manifest.scopes.length === 0;

			// Retrieve the categories array or use an empty array if it's undefined.
			const categories = manifest.categories || [];

			// If the manifest has 'ANY' scope, add it to each of its categories.
			if (isAnyScope) {
				for (const category of categories) {
					// Convert the category name to a space-separated string.
					const categoryName = convertPascalToSpaceCase(category);

					// Ensure the group exists for this category.
					groups[categoryName] = groups[categoryName] || { name: categoryName, manifests: [] };

					// Add the manifest to the category's group.
					groups[categoryName].manifests.push(manifest);
				}

				// Skip processing other scopes since 'ANY' covers all.
				continue;
			}

			// If no 'ANY' scope, iterate through each category and scope.
			for (const category of categories) {
				for (const scope of manifest.scopes) {
					// Create a combined category name (e.g., "Category (Scope)").
					const categoryName = `${convertPascalToSpaceCase(category)} (${convertPascalToSpaceCase(scope)})`;

					// Ensure the group exists for this combined category and scope.
					groups[categoryName] = groups[categoryName] || { name: categoryName, manifests: [] };

					// Add the manifest to the combined group's manifests.
					groups[categoryName].manifests.push(manifest);
				}
			}
		}

		// Return the organized groups.
		return groups;
	}

	/**
	 * Fetches and returns G4 manifests of type 'Action'.
	 * Caches the manifests after the first fetch to avoid redundant network requests.
	 * 
	 * @returns {Promise<Object>} A promise that resolves to the manifests object.
	 * 
	 * @throws Will throw an error if the network request fails.
	 */
	async getManifests() {
		// If manifests are already cached, return them directly.
		if (this.manifests.length > 0) {
			return this.manifests;
		}

        // Define the plugin types to include in the fetch request.
		const includeTypes = ["ACTION", "CONTENT", "TRANSFORMER"];

		try {
			// Fetch the plugin manifests from the API.
			const response = await fetch(this.manifestsUrl);

			// Check if the response status is OK (HTTP 200-299).
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON response.
			const data = await response.json();

			// Filter only the plugins of type 'Action' and organize them into a dictionary by `key`.
			this.manifests = data
				.filter(item => includeTypes.includes(item.pluginType.toUpperCase()))
				.reduce((cache, manifest) => {
					// Use the `key` field of the manifest as the dictionary key.
					cache[manifest.key] = manifest;
					return cache;
				}, {});

			return this.manifests; // Return the cached manifests.
		} catch (error) {
			// Log the error for debugging and rethrow it.
			console.error('Failed to fetch G4 plugins:', error);
			throw new Error(error);
		}
	}

	/**
	 * Invokes the G4 Automation Sequence by sending a POST request with the provided definition.
	 *
	 * This asynchronous function sends a JSON payload to a predefined automation URL using the Fetch API.
	 * It handles the response by parsing the returned JSON data and managing errors that may occur during the request.
	 *
	 * @async
	 * @function invokeAutomation
	 * 
	 * @param    {Object} definition - The automation definition object to be sent in the POST request body.
	 * 
	 * @returns  {Promise<Object>} - A promise that resolves to the parsed JSON response data from the server.
	 * 
	 * @throws   {Error} - Throws an error if the network response is not ok or if the fetch operation fails.
	 */
	async invokeAutomation(definition) {
		try {
			// Invoke the G4 automation sequence by sending a POST request with the automation definition.
			const response = await fetch(this.invokeUrl, {
				method: 'POST', // HTTP method set to POST for sending data
				headers: {
					'Content-Type': 'application/json' // Indicates that the request body is in JSON format
				},
				body: JSON.stringify(definition) // Converts the definition object to a JSON string for the request body
			});

			// Check if the response status indicates a successful request (HTTP status code 200-299).
			if (!response.ok) {
				// If the response is not ok, throw an error with the status text for debugging purposes.
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON data from the successful response.
			const data = await response.json();

			// Return the parsed data for further processing by the caller.
			return data;
		} catch (error) {
			// Log the error to the console for debugging and monitoring purposes.
			console.error('Failed to invoke G4 automation:', error);

			// Rethrow the original error to ensure that the caller can handle it appropriately.
			// Using 'throw error' preserves the original error stack and message.
			throw error;
		}
	}

	/**
	 * Resolves all macros for the G4 Automation Sequence by sending a POST request with the provided definition.
	 *
	 * This asynchronous function sends a JSON payload to a predefined automation URL using the Fetch API.
	 * It handles the response by parsing the returned JSON data and managing errors that may occur during the request.
	 *
	 * @async
	 * @function invokeAutomation
	 * 
	 * @param    {Object} definition - The automation definition object to be sent in the POST request body.
	 * 
	 * @returns  {Promise<Object>} - A promise that resolves to the parsed JSON response data from the server.
	 * 
	 * @throws   {Error} - Throws an error if the network response is not ok or if the fetch operation fails.
	 */
	async resolveMacros(definition) {
		try {
			// Resolve the G4 automation sequence by sending a POST request with the automation definition.
			const response = await fetch(this.macrosUrl, {
				method: 'POST',
				headers: {
					'Content-Type': 'application/json'
				},
				body: JSON.stringify(definition)
			});

			// Check if the response status indicates a successful request (HTTP status code 200-299).
			// If the response is not ok, throw an error with the status text for debugging purposes.
			if (!response.ok) {
				throw new Error(`Network response was not ok: ${response.statusText}`);
			}

			// Parse the JSON data from the successful response.
			const data = await response.json();

			// Return the parsed data for further processing by the caller.
			return data;
		} catch (error) {
			// Log the error to the console for debugging and monitoring purposes.
			console.error('Failed to resolve G4 automation:', error);

			// Rethrow the original error to ensure that the caller can handle it appropriately.
			// Using 'throw error' preserves the original error stack and message.
			throw error;
		}
	}

	/**
	 * Constructs a new automation object using the provided definition, which includes properties for
	 * authentication, driver parameters, settings, and sequences of stages and jobs.
	 *
	 * @function newAutomation
	 * 
	 * @param {Object} definition                               - The definition object describing the automation flow.
	 * @param {Object} definition.properties                    - The properties of the automation, including authentication, driver parameters, and settings.
	 * @param {Object} [definition.properties.authentication]   - Optional authentication details (e.g., tokens or credentials).
	 * @param {Object} [definition.properties.driverParameters] - Optional driver parameters (e.g., capabilities for WebDriver).
	 * @param {Object} [definition.properties.settings]         - Optional additional settings (e.g., timeouts, logging preferences).
	 * @param {Array}  definition.sequence                      - An array of stages, each of which may contain multiple jobs.
	 * 
	 * @returns {Object} The newly constructed automation object containing authentication, driver parameters, settings, and stages.
	 */
	newAutomation(definition) {
		/**
		 * Formats and merges driver parameters, ensuring that vendor-specific capabilities
		 * are placed under the correct keys (e.g., `{vendorName}:options`). This function
		 * constructs a standardized `parameters` object that can be passed to a WebDriver
		 * or similar driver-configuration mechanism.
		 *
		 * @function formatDriverParameters
		 * 
		 * @param {Object} [driverParameters] - The raw driver parameters, potentially containing capabilities and vendor-specific settings.
		 * @param {Object} [driverParameters.capabilities]                    - Root WebDriver capabilities.
		 * @param {Object} [driverParameters.capabilities.vendorCapabilities] - An object mapping vendor keys to vendor-specific capabilities.
		 * @param {string} [driverParameters.driver]                          - The driver identifier (e.g., a browser driver name).
		 * @param {Object} [driverParameters.driverBinaries]                  - Driver-specific binaries or paths.
		 * 
		 * @returns {Object} A new parameters object with correctly placed vendor options, or the original `driverParameters` if capabilities are missing.
		 */
		const formatDriverParameters = (driverParameters) => {
			// Extract the main capabilities and vendor capabilities from the input object.
			const capabilities = driverParameters?.capabilities || {};
			const vendorCapabilities = capabilities.vendorCapabilities || {};

			// Create a base parameters object with minimal fields.
			let parameters = {
				capabilities: {},
				driver: driverParameters?.driver,
				driverBinaries: driverParameters?.driverBinaries,
			};

			// If there are no capabilities or vendorCapabilities, return the original object as-is.
			if (!capabilities || !vendorCapabilities) {
				return driverParameters;
			}

			// Assign the alwaysMatch and firstMatch capabilities directly.
			parameters.capabilities.alwaysMatch = capabilities.alwaysMatch;
			parameters.capabilities.firstMatch = capabilities.firstMatch;

			// Loop through each vendor key and add its capabilities under `{vendor}:options`.
			const vendorKeys = Object.keys(vendorCapabilities);
			for (const vendorKey of vendorKeys) {
				// Construct the vendor options key, e.g., "goog:chromeOptions".
				const vendorOptionsKey = `${vendorCapabilities[vendorKey]?.vendor}:options`;

				// Add the vendor-specific capabilities to alwaysMatch under the new key.
				parameters.capabilities.alwaysMatch[vendorOptionsKey] =
					vendorCapabilities[vendorKey]?.capabilities;
			}

			// Return the fully constructed parameters object.
			return parameters;
		};

		// Extract the authentication parameters from the definition properties.
		const authentication = definition.properties["authentication"];

		// Extract and format the driver parameters from the definition properties using the helper function.
		const driverParameters = formatDriverParameters(definition.properties?.driverParameters);

		// Extract additional settings (if any) from the definition properties.
		const settings = definition.properties["settings"] || undefined;

		// Prepare an array to collect stages from the definition sequence.
		const stages = [];

		// Iterate over each stage in the definition's sequence.
		for (const stage of definition.sequence) {
			// Construct a new stage object with minimal required properties.
			const newStage = {
				// Stage-level driver parameters (if provided).
				driverParameters: formatDriverParameters(stage.properties?.driverParameters),

				// A reference object that captures key metadata about the stage.
				reference: {
					description: stage.description,
					id: stage.id,
					name: stage.name,
				},

				// Each stage contains multiple jobs.
				jobs: [],
			};

			// Iterate over each job in the current stage.
			for (const job of stage.sequence) {
				// Construct a new job object.
				const newJob = {
					// Job-level driver parameters (if provided).
					driverParameters: formatDriverParameters(job.properties?.driverParameters),

					// A reference object that captures key metadata about the job.
					reference: {
						description: job.description,
						id: job.id,
						name: job.name,
					},

					// Each job contains multiple rules derived from its steps.
					rules: [],
				};

				// Convert each step in the job's sequence into a rule, then add it to the job.
				for (const step of job.sequence) {
					const rule = this.convertToRule(step);
					newJob.rules.push(rule);
				}

				// Add the populated job to the current stage.
				newStage.jobs.push(newJob);
			}

			// After processing all jobs, add the completed stage to the main stages array.
			stages.push(newStage);
		}

		// Return a newly constructed automation object containing all relevant data.
		return {
			// Store any authentication details passed in.
			authentication,

			// Include optional driver parameters (e.g., session data).
			driverParameters,

			// Include any additional settings (e.g., timeouts, logging).
			settings,

			// Provide the fully constructed set of stages (each containing jobs and rules).
			stages,
		};
	}
}
